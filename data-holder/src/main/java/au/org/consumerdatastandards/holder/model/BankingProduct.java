/*
 * Consumer Data Standards
 * Sample Data Holder to Demonstrate the Consumer Data Right APIs
 *
 * NOTE: This class is auto generated by the codegen artefact
 * https://github.com/ConsumerDataStandardsAustralia/java-artefacts/codegen
 * Do not edit the class manually.
 */
package au.org.consumerdatastandards.holder.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.format.annotation.DateTimeFormat.ISO;

import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.lang.reflect.Field;
import java.time.OffsetDateTime;
import java.util.Objects;

@Entity
@Table(name = "BankingProduct")
public class BankingProduct  {
    // A provider specific unique identifier for this product. This
    // identifier must be unique to a product but does not
    // otherwise need to adhere to ID permanence guidelines.
    @Id
    @JsonProperty("productId")    
    private String productId;
    
    // The date and time from which this product is effective (ie.
    // is available for origination).  Used to enable the
    // articulation of products to the regime before they are
    // available for customers to originate
    @JsonProperty("effectiveFrom")
    @DateTimeFormat(iso = ISO.DATE_TIME)
    @JsonFormat(shape = JsonFormat.Shape.STRING)        
    private OffsetDateTime effectiveFrom;

    // The date and time at which this product will be retired and
    // will no longer be offered.  Used to enable the managed
    // deprecation of products
    @JsonProperty("effectiveTo")
    @DateTimeFormat(iso = ISO.DATE_TIME)
    @JsonFormat(shape = JsonFormat.Shape.STRING)    
    private OffsetDateTime effectiveTo;

    // The last date and time that the information for this product
    // was changed (or the creation date for the product if it has
    // never been altered)
    @JsonProperty("lastUpdated")
    @DateTimeFormat(iso = ISO.DATE_TIME)
    @JsonFormat(shape = JsonFormat.Shape.STRING)    
    private OffsetDateTime lastUpdated;

    @JsonProperty("productCategory")
    private BankingEnumProductCategory productCategory;

    // The display name of the product
    @JsonProperty("name")
    private String name;

    // A description of the product
    @JsonProperty("description")
    private String description;

    // A label of the brand for the product. Able to be used for
    // filtering. For data providers with single brands this value
    // is still required
    @JsonProperty("brand")
    private String brand;

    // An optional display name of the brand
    @JsonProperty("brandName")
    private String brandName;

    // A link to an application web page where this product can be
    // applied for.
    @JsonProperty("applicationUri")
    private String applicationUri;

    // Indicates whether the product is specifically tailored to a
    // circumstance.  In this case fees and prices are
    // significantly negotiated depending on context. While all
    // products are open to a degree of tailoring this flag
    // indicates that tailoring is expected and thus that the
    // provision of specific fees and rates is not applicable
    @JsonProperty("isTailored")
    private Boolean isTailored;

    @JsonProperty("additionalInformation")
    @Embedded
    private BankingProductAdditionalInformation additionalInformation;

    
    public String getProductId() {
        return productId;
    }

    public void setProductId(String productId) {
        this.productId = productId;
    }
    
    public OffsetDateTime getEffectiveFrom() {
        return effectiveFrom;
    }

    public void setEffectiveFrom(OffsetDateTime effectiveFrom) {
        this.effectiveFrom = effectiveFrom;
    }
    
    public OffsetDateTime getEffectiveTo() {
        return effectiveTo;
    }

    public void setEffectiveTo(OffsetDateTime effectiveTo) {
        this.effectiveTo = effectiveTo;
    }
    
    public OffsetDateTime getLastUpdated() {
        return lastUpdated;
    }

    public void setLastUpdated(OffsetDateTime lastUpdated) {
        this.lastUpdated = lastUpdated;
    }
    
    public BankingEnumProductCategory getProductCategory() {
        return productCategory;
    }

    public void setProductCategory(BankingEnumProductCategory productCategory) {
        this.productCategory = productCategory;
    }
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }
    
    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }
    
    public String getApplicationUri() {
        return applicationUri;
    }

    public void setApplicationUri(String applicationUri) {
        this.applicationUri = applicationUri;
    }
    
    public Boolean getIsTailored() {
        return isTailored;
    }

    public void setIsTailored(Boolean isTailored) {
        this.isTailored = isTailored;
    }
    
    public BankingProductAdditionalInformation getAdditionalInformation() {
        return additionalInformation;
    }

    public void setAdditionalInformation(BankingProductAdditionalInformation additionalInformation) {
        this.additionalInformation = additionalInformation;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        
        BankingProduct inputModel = (BankingProduct) o;
        if(! (productId.equals(inputModel.getProductId()))) { return false; }
        if(! (effectiveFrom.equals(inputModel.getEffectiveFrom()))) { return false; }
        if(! (effectiveTo.equals(inputModel.getEffectiveTo()))) { return false; }
        if(! (lastUpdated.equals(inputModel.getLastUpdated()))) { return false; }
        if(! (productCategory.equals(inputModel.getProductCategory()))) { return false; }
        if(! (name.equals(inputModel.getName()))) { return false; }
        if(! (description.equals(inputModel.getDescription()))) { return false; }
        if(! (brand.equals(inputModel.getBrand()))) { return false; }
        if(! (brandName.equals(inputModel.getBrandName()))) { return false; }
        if(! (applicationUri.equals(inputModel.getApplicationUri()))) { return false; }
        if(! (isTailored.equals(inputModel.getIsTailored()))) { return false; }
        return additionalInformation.equals(inputModel.getAdditionalInformation());
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            productId,
            effectiveFrom,
            effectiveTo,
            lastUpdated,
            productCategory,
            name,
            description,
            brand,
            brandName,
            applicationUri,
            isTailored,
            additionalInformation);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("class %s {\n", getClass()));

        for (Field oneField : getClass().getFields()) {
            oneField.setAccessible(true);
            try {
                sb.append(String.format("    %s: %s\n", oneField.getName(), (oneField.get(Object.class) == null ? "null"
                        : oneField.get(Object.class).toString().replace("\n", "\n    "))));
            } catch (IllegalArgumentException | IllegalAccessException e) {
                sb.append(String.format("    %s, [unreadable]\n", oneField.getName()));
            }
        }
        sb.append("}");
        return sb.toString();
    }
}
