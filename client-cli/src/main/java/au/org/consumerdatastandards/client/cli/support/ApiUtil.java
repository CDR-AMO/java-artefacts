/*
 * Consumer Data Standards
 * Sample CLI tool to Demonstrate the Consumer Data Right APIs
 *
 * NOTE: This class is auto generated by the codegen artefact
 * https://github.com/ConsumerDataStandardsAustralia/java-artefacts/codegen
 */
package au.org.consumerdatastandards.client.cli.support;

import au.org.consumerdatastandards.client.ApiClient;
import au.org.consumerdatastandards.client.ApiException;
import ch.qos.logback.classic.Logger;
import com.google.inject.CreationException;
import okhttp3.Credentials;
import okhttp3.OkHttpClient;
import okhttp3.tls.HandshakeCertificates;
import okhttp3.tls.HeldCertificate;
import org.apache.commons.lang3.StringUtils;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;
import org.slf4j.LoggerFactory;

import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.X509TrustManager;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URL;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;
import java.util.List;

public class ApiUtil {

    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ApiUtil.class);
    private static final List<String> VALID_PROXY_TYPES = Arrays.asList("HTTP:", "HTTPS:", "SOCKS:");

    public static ApiClient createApiClient(ApiClientOptions clientOptions) throws ApiException {
        String serverUrl = clientOptions.getServerUrl();
        if (StringUtils.isBlank(serverUrl)) {
            LOGGER.error("Server Base URL is currently unset, cannot proceed until it is specified using `server` command");
            throw new ApiException("Server URL not set, please use `server` command to set Server URL first");
        }
        if (!isValidUrl(serverUrl)) {
            LOGGER.error("Invalid server url of {} specified, please double check", serverUrl);
            throw new ApiException("Invalid Server URL, please double check it");
        }
        ApiClient apiClient = new ApiClient();
        OkHttpClient originalHttpClient = apiClient.getHttpClient();
        apiClient.setBasePath(serverUrl);
        LOGGER.info("Server Base URL is set to {}", serverUrl);
        String userAgent = clientOptions.getUserAgent();
        if (!StringUtils.isBlank(userAgent)) {
            apiClient.setUserAgent(userAgent);
            LOGGER.info("User Agent is set to {}", userAgent);
        }

        String accessToken = clientOptions.getAccessToken();
        if (StringUtils.isNotBlank(accessToken)) {
            apiClient.addDefaultHeader("Authorization", "Bearer " + accessToken);
        }
        if (clientOptions.isMtlsEnabled()) {
            validateClientCertSettings(clientOptions);
            String keyFilePath = clientOptions.getKeyFilePath();
            String certFilePath = clientOptions.getCertFilePath();
            try {
                X509Certificate certificate = loadCertificate(certFilePath);
                PublicKey publicKey = certificate.getPublicKey();
                PrivateKey privateKey = loadPrivateKey(keyFilePath);
                KeyPair keyPair = new KeyPair(publicKey, privateKey);
                OkHttpClient httpClient = buildHttpClient(originalHttpClient,
                    new HeldCertificate(keyPair, certificate));
                apiClient.setHttpClient(httpClient);
            } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException | CreationException | CertificateException e) {
                throw new ApiException(e);
            }
            LOGGER.info("Enabled MTLS");
        } else {
            apiClient.setHttpClient(originalHttpClient);
            LOGGER.info("Disabled MTLS");
        }
        String proxy = clientOptions.getProxy();
        if (!StringUtils.isBlank(proxy)) {
            setProxy(apiClient, proxy);
            LOGGER.info("Proxy is set to {}", proxy);
        }
        apiClient.setDebugging(clientOptions.isDebugEnabled());
        LOGGER.info("Debugging is set to {}", apiClient.isDebugging());
        apiClient.setVerifyingSsl(clientOptions.isVerifyingSsl());
        LOGGER.info("Verifying SSL is set to {}", apiClient.isVerifyingSsl());

        return apiClient;
    }

    private static X509Certificate loadCertificate(String certFilePath) throws CertificateException, FileNotFoundException {
        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
        return (X509Certificate) certificateFactory.generateCertificate(new FileInputStream(certFilePath));
    }

    private static PrivateKey loadPrivateKey(String keyFilePath)
        throws IOException, ApiException, NoSuchAlgorithmException, InvalidKeySpecException {
        Security.addProvider(new BouncyCastleProvider());
        FileReader reader = new FileReader(keyFilePath);
        PemReader pemReader = new PemReader(reader);
        PemObject pemObject = pemReader.readPemObject();
        String type = pemObject.getType();
        final String PRIVATE_KEY_TYPE_SUFFIX = "PRIVATE KEY";
        if (!type.endsWith(PRIVATE_KEY_TYPE_SUFFIX)) {
            throw new ApiException("Invalid key file content - expecting first line similar to\n" +
                "-----BEGIN RSA PRIVATE KEY-----");
        }
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pemObject.getContent());
        String algorithmName = type.replace(PRIVATE_KEY_TYPE_SUFFIX, "").trim();
        if (StringUtils.isNotBlank(algorithmName)){
            KeyFactory kf = KeyFactory.getInstance(algorithmName);
            return kf.generatePrivate(keySpec);
        } else {
             String[] algos = {"RSA", "DSA", "EC"};
             for (String algo: algos) {
                 PrivateKey key = tryGeneratingPrivateKey(keySpec, algo);
                 if (key != null) return key;
             }
             throw new ApiException("Unsupported public key algorithm");
        }
    }

    private static PrivateKey tryGeneratingPrivateKey(KeySpec keySpec, String algorithmName) throws NoSuchAlgorithmException {
        KeyFactory kf = KeyFactory.getInstance(algorithmName);
        try {
            return kf.generatePrivate(keySpec);
        } catch (InvalidKeySpecException e) {
            return null;
        }
    }

    private static OkHttpClient buildHttpClient(OkHttpClient httpClient,
                                                HeldCertificate heldCertificate,
                                                X509Certificate... intermediates) {
        HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
            .addPlatformTrustedCertificates();

        if (heldCertificate != null) {
            builder.heldCertificate(heldCertificate, intermediates);
        }

        HandshakeCertificates handshakeCertificates = builder.build();
        SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
        X509TrustManager trustManager = handshakeCertificates.trustManager();
        return httpClient.newBuilder().sslSocketFactory(sslSocketFactory, trustManager).build();
    }

    private static void validateClientCertSettings(ApiClientOptions clientOptions) throws ApiException {
        String certFilePath = clientOptions.getCertFilePath();
        String keyFilePath = clientOptions.getKeyFilePath();
        if (StringUtils.isBlank(certFilePath)) {
            throw new ApiException("Client certificate path is not set");
        }
        if (StringUtils.isBlank(keyFilePath)) {
            throw new ApiException("Key file path is not set");
        }
        File certFile = new File(certFilePath);
        File keyFile = new File(keyFilePath);
        if (!certFile.exists()) {
            throw new ApiException("Certificate file " + certFilePath + " cannot be found");
        }
        if (!keyFile.exists()) {
            throw new ApiException("Key file " + keyFilePath + " cannot be found");
        }
    }

    private static void setProxy(ApiClient apiClient, String proxy) throws ApiException {
        OkHttpClient.Builder builder = apiClient.getHttpClient().newBuilder();
        if ("none".equalsIgnoreCase(proxy)) {
            builder.proxy(Proxy.NO_PROXY);
        } else {
            String[] typeAndOther = proxy.split("//");
            if (typeAndOther.length != 2) {
                printProxyExamples();
                throw new ApiException("Invalid proxy, please double check it.");
            }
            if (!VALID_PROXY_TYPES.contains(typeAndOther[0].toUpperCase())) {
                printProxyExamples();
                throw new ApiException("Invalid proxy, please double check it.");
            }
            String[] authAndOther = typeAndOther[1].split("@");
            if (authAndOther.length > 2) {
                printProxyExamples();
                throw new ApiException("Invalid proxy, please double check it.");
            }
            String[] hostAndPort = authAndOther[authAndOther.length - 1].split(":");
            if (hostAndPort.length != 2) {
                printProxyExamples();
                throw new ApiException("Invalid proxy, please double check it.");
            }
            String host = hostAndPort[0];
            String port = hostAndPort[1];
            if (!port.matches("[1-9]\\d*")) {
                printProxyExamples();
                throw new ApiException("Invalid proxy, please double check it.");
            }
            int portNumber = Integer.parseInt(port);
            builder.proxy(new Proxy(getProxyType(typeAndOther[0]), new InetSocketAddress(host, portNumber)));
            if (authAndOther.length > 1) {
                String[] userAndPass = authAndOther[0].split(":", 2);
                if (userAndPass.length != 2) {
                    printProxyExamples();
                    throw new ApiException("Invalid proxy, please double check it.");
                }
                okhttp3.Authenticator proxyAuthenticator = (route, response) -> {
                    String credential = Credentials.basic(userAndPass[0], userAndPass[1]);
                    return response.request().newBuilder()
                        .header("Proxy-Authorization", credential)
                        .build();
                };
                builder.proxyAuthenticator(proxyAuthenticator);
            }
        }
        apiClient.setHttpClient(builder.build());
    }

    private static Proxy.Type getProxyType(String type) {
        if (type.equalsIgnoreCase("socks:")) {
            return Proxy.Type.SOCKS;
        }
        return Proxy.Type.HTTP;
    }

    private static void printProxyExamples() {
        LOGGER.info("Valid proxy examples:");
        LOGGER.info("http://http.proxy:8080");
        LOGGER.info("https://https.proxy:8443");
        LOGGER.info("socks://socks.proxy:5500");
        LOGGER.info("http://user:pass@http.proxy:8080");
        LOGGER.info("https://user:pass@https.proxy:8443");
        LOGGER.info("socks://user:pass@socks.proxy:5500");
    }

    private static boolean isValidUrl(String url) {
        String lowerCaseUrl = url.toLowerCase();
        if (!lowerCaseUrl.startsWith("https://") && !lowerCaseUrl.startsWith("http://")) {
            LOGGER.error("Invalid scheme specified for server url, only https:// and http:// are supported");
            return false;
        }
        try {
            new URL(url);
            LOGGER.trace("Server URL of {} passes validation", url);
            return true;
        } catch (MalformedURLException e) {
            LOGGER.error("Specified URL of {} is malformed and exception caught: {}", url, e.getMessage());
            return false;
        }
    }
}
